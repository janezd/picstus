/* -*- Mode:C -*-
 *
 * This file is linked and #included into the containing executable (as
 * generated by spld/splfr).
 *
 */

/* [PM] 3.9b5 This file contain templates both for spld generated
   executables (if SPLD_GENERATE_MAIN is true) and templates for
   foreign resource glue code (if SPLD_GENERATE_MAIN is not set).
 */

#if SPLD_GENERATE_MAIN

/*
  [PM] 3.9b5 Generate main function for spld
  Inputs:
  SPLD_MAIN_NAME -- name of function. A C identifier
  SPLD_DSP -- Development system, 0 (RT) or 1 (DS) (or 2 Extended RT?).
  SPLD_BOOTPATH -- Bootpath, undefined or string literal.
  SPLD_INTERACTIVE -- undefined or 1
  SPLD_MEMHOOK -- undefined or one of the MM_USE_XXX constants
  SPLD_USERHOOK -- undefined or 1
  SPLD_LANGUAGE -- 1 for sicstus, 2 for iso
  SPLD_SAV_FILE -- sav file to restore, undefined or string literal.
  SPLD_LOAD_FILES -- files to SP_load, undefined or brace enclosed, 0 terminated list of string literals
*/
int SPCDECL SPLD_MAIN_NAME(int argc, char *argv[])
{
  int dsp;
  char *bootpath = NULL;
  int rv;
  int sp_argc;
  char **sp_argv;
  SP_pred_ref main_pred;

  dsp = (SPLD_DSP+0);

#ifdef SPLD_BOOTPATH
  bootpath = SPLD_BOOTPATH;
#endif /* SPLD_BOOTPATH */

  SetupSICStusDISPATCH();       /* not strictly needed. Done by SU_initialize */
  
#ifdef SPLD_MEMHOOK             /* --memhook=XXX */
  SP_set_memalloc_hooks(SPLD_MEMHOOK, 0,0,0,0);
#endif /* SPLD_MEMHOOK */

#if SPLD_INTERACTIVE
  SP_force_interactive();
#endif /* SPLD_INTERACTIVE */

#if SPLD_USERHOOK
  if (0 != (rv = SU_initialize(argc,argv)))
    {
      return rv;
    }
#endif /* SPLD_USERHOOK */

  sp_argc = argc-1;
  sp_argv = &argv[1];
  rv = glue_initialize(sp_argc,sp_argv,bootpath,sp_pre_linkage,sp_pre_map,dsp,1);

  if (rv != SP_SUCCESS)
    {
      if (SP_errno == 3 /* NOT_FIND_BOOTFILE */)
        {
          fprintf(stderr, "! Prolog engine initialization failed: could not find bootfile %s\n",
                  sp_get_failed_bootpath()); fflush(stderr);
        }
      else if (SP_errno)
        {
          fprintf(stderr, "! Prolog engine initialization failed: %s\n", SP_error_message(SP_errno)); fflush(stderr);
        }
      else
        {
          fprintf(stderr, "! Prolog engine initialization failed\n"); fflush(stderr);
        }
      return 1;
    }

#ifdef SPLD_LANGUAGE             /* --lang= */
  {
    char *goal;
    SP_pred_ref call_1_pred;
    SP_term_ref goal_term = SP_new_term_ref();
    switch (SPLD_LANGUAGE)
      {
      default:
      case 1:                   /* sicstus */
        goal = "prolog_flag(language,_,sicstus).";
        break;
      case 2:                   /* iso */
        goal = "prolog_flag(language,_,iso).";
        break;
      }
    if (!SP_read_from_string(goal_term, goal, 0))
      {
        fprintf(stderr,"! Could not set language (SP_read_from_string \"%s\").\n", goal); fflush(stderr);
        return 1;
      }
    call_1_pred = SP_predicate("call",1,"user");
    if (!call_1_pred)
      {
        fprintf(stderr,"! Could not find predicate user:call/1.\n"); fflush(stderr);
        return 1;
      }
    rv = SP_query_cut_fail(call_1_pred, goal_term);
    if (rv != SP_SUCCESS)
      {
        fprintf(stderr,"! Could not set language (call(\"%s\")).\n", goal); fflush(stderr);
        return 1;
      }
    SP_reset_term_refs(goal_term);
  }
#endif /* SPLD_LANGUAGE */

#ifdef SPLD_SAV_FILE
  rv = SP_restore(SPLD_SAV_FILE);
  if (rv != SP_SUCCESS)
    {
      fprintf(stderr,"! Could not restore \"" SPLD_SAV_FILE "\".\n"); fflush(stderr);
      return 1;
    }
#endif /* SPLD_SAV_FILE */

#ifdef SPLD_LOAD_FILES
  {
    char* load_files[] = SPLD_LOAD_FILES;
    char** pf;
    
    for (pf = &load_files[0]; *pf; pf++)
      {
        /* .pl, .ql, and .po are handled by SP_load() */
        rv = SP_load(*pf);
        if (rv != SP_SUCCESS)
          {
            fprintf(stderr,"! Could not load \"%s\".\n", *pf); fflush(stderr);
            return 1;
          }
      }
  }
#endif /* SPLD_LOAD_FILES */

  main_pred = SP_predicate("main",0,"prolog"); /* known to exist */
  if (main_pred == NULL)
    {
      fprintf(stderr,"! Could not find entrypoint: %s\n",SP_error_message(SP_errno)); fflush(stderr);
      return 1;
    }
  rv = SP_query(main_pred);

  return ((rv==SP_SUCCESS) ? 0 : 1);
}


#if !SPLD_USERHOOK /* this is needed for development systems (called by user_main in main.c) */
int SPCDECL SU_initialize(int argc, char *argv[]) {
  (void)argc; (void)argv;
   return 0;
}
#endif /* !SPLD_USERHOOK */


#endif /* SPLD_GENERATE_MAIN */


#if !SPLD_GENERATE_MAIN

#ifndef SP_DYNAMIC_FOREIGN_RESOURCE
#define SP_DYNAMIC_FOREIGN_RESOURCE (SPDLL+0)
#endif

#if (SPDLL || SP_DYNAMIC_FOREIGN_RESOURCE)
#if SP_DYNAMIC_FOREIGN_RESOURCE != SPDLL
#error "C macro inconsistency, SP_DYNAMIC_FOREIGN_RESOURCE should always equal SPDLL"
#endif /* SP_DYNAMIC_FOREIGN_RESOURCE */
#endif /* (SPDLL || SP_DYNAMIC_FOREIGN_RESOURCE) */

#define INCLUDED_IN_FOREIGN_RESOURCE (SP_STATIC_FOREIGN_RESOURCE || SP_DYNAMIC_FOREIGN_RESOURCE)

#if LOCAL_INCLUDES
   #include "sicstus.h"
#else
   #include <sicstus/sicstus.h> /* typedef SICSTUS_DISPATCH_TABLE */
#endif /* LOCAL_INCLUDES */

#ifdef SP_DISPATCH_API          /* [PM] 3.9b5 assumed 1 if undefined in public headers & source */
#if !SP_DISPATCH_API /* 3.9 dispatch-based API */
#error "only SP_DISPATCH_API supported"
#endif /* !SP_DISPATCH_API */
#endif /* SP_DISPATCH_API */

#if !SP_STATIC_FOREIGN_RESOURCE /* if static then instead use main app sp_GlobalSICStus */

#if (MULTI_SP_AWARE && SP_DYNAMIC_FOREIGN_RESOURCE)
/* A multi SP need to pass around the API so should need no global variable for API */
/* nothing */
#else  /* !(MULTI_SP_AWARE && SP_DYNAMIC_FOREIGN_RESOURCE) */
/* This is also the SP_SINGLE_THREADED case */

/* By default what GetSICStusDISPATCH() returns */
SICSTUS_API_STRUCT_TYPE *sp_GlobalSICStus = 0;
#endif /* !(MULTI_SP_AWARE && SP_DYNAMIC_FOREIGN_RESOURCE) */

#endif /* !SP_STATIC_FOREIGN_RESOURCE */

#if INCLUDED_IN_FOREIGN_RESOURCE /* [PM] 3.9b4 rest of file only used when included in foreign resource. */

#if WINCE
static void wince_abort()
{
  exit(3);
}
#define abort wince_abort
#endif /* WINCE */

#if INCLUDED_IN_FOREIGN_RESOURCE

#ifndef SP_RES_DBG
#define SP_RES_DBG 0                  /* #define as 0 to suppress verbose output */
#endif

#ifndef SP_RES_DBG
#define SP_RES_DBG (DBG+0)
#endif /* SP_RES_DBG */

#if SP_RES_DBG
#define SP_RES_IF_DBG(STMT) STMT
#else  /* !SP_RES_DBG */
#define SP_RES_IF_DBG(STMT)
#endif /* !SP_RES_DBG */


/* [PM] 3.9 These should handle various degrees of MULTI SP awareness in each foreign function stub
            See internals.tex for more info.
*/

#if SP_SINGLE_THREADED
#if DBG

#if __GNUC__
static void *sp_DEBUG_LOCK(char *mutexname, SP_mutex *mutex) __attribute__ ((unused));
#endif /* __GNUC__ */

static void *sp_DEBUG_LOCK(char *mutexname, SP_mutex *mutex)
{
  (void)mutexname;              /* [PM] 3.9b5 avoid -Wunused */
  (void)mutex;                  /* [PM] 3.9b5 avoid -Wunused */

  SP_RES_IF_DBG(fprintf(stderr, "\n *** DEBUG: locking %s (%p)\n", mutexname, (void*)mutex));
  SP_RES_IF_DBG(fflush(stderr));
  return 0;
}

#if __GNUC__
static void *sp_DEBUG_UNLOCK(char *mutexname, SP_mutex *mutex) __attribute__ ((unused));
#endif /* __GNUC__ */


static void *sp_DEBUG_UNLOCK(char *mutexname, SP_mutex *mutex)
{
  (void)mutexname;              /* [PM] 3.9b5 avoid -Wunused */
  (void)mutex;                  /* [PM] 3.9b5 avoid -Wunused */

  SP_RES_IF_DBG(fprintf(stderr, "\n *** DEBUG: unlocking %s (%p)\n", mutexname, (void*)mutex));
  SP_RES_IF_DBG(fflush(stderr));
  return 0;
}

#define DEBUG_LOCK_COMMA(MUTEX) sp_DEBUG_LOCK(#MUTEX, &(MUTEX)),
#define DEBUG_UNLOCK_COMMA(MUTEX) sp_DEBUG_UNLOCK(#MUTEX, &(MUTEX)),
#else  /* !DBG */
#define DEBUG_LOCK_COMMA(_MUTEX)
#define DEBUG_UNLOCK_COMMA(_MUTEX)
#endif /* !DBG */

#define SP_MUTEX_LOCK_OTHER(SPAPI,MUTEX) ((DEBUG_LOCK_COMMA(MUTEX)(SPAPI)->dispatch_API_SICSTUS_H->pSP_mutex_lock)(&(MUTEX)))
#define SP_MUTEX_UNLOCK_OTHER(SPAPI,MUTEX) ((DEBUG_UNLOCK_COMMA(MUTEX)(SPAPI)->dispatch_API_SICSTUS_H->pSP_mutex_unlock)(&(MUTEX)))

/* xref flids.c */
#define SP_LOCK_SINGLE_THREADED_RESOURCE(RESNAME,SPAPI) SP_MUTEX_LOCK_OTHER(SPAPI,sp_resource_mutex_ ## RESNAME)
#define SP_UNLOCK_SINGLE_THREADED_RESOURCE(RESNAME,SPAPI) SP_MUTEX_UNLOCK_OTHER(SPAPI,sp_resource_mutex_ ## RESNAME)

#endif /* SP_SINGLE_THREADED */

#if MULTI_SP_AWARE
       #if SP_SINGLE_THREADED
       #error "MULTI_SP_AWARE and SP_SINGLE_THREADED are incompatible"
       #endif /* SP_SINGLE_THREADED */

       /* xref flids.c */

       #define SP_STUB_LOCAL_DECLARATIONS(_RESNAME) SPAPI_ARG_LOCAL_DECL
       #if SP_FOREIGN_SPENV || 1 /* 3.9 always on */
       #define SP_STUB_SETUP_API(_RESNAME) SPAPI_ARG_NAME = spenv;
       #elif SP_FOREIGN_STASH
       #define SP_STUB_SETUP_API(_RESNAME) SPAPI_ARG_NAME = (*(glue_flidata)).api; SPAPI_STASH_NAME = pstash;
       #else /* !SP_FOREIGN_STASH */
       #define SP_STUB_SETUP_API(_RESNAME) SPAPI_ARG_NAME = (*(glue_flidata)).api;
       #endif                          /* !SP_FOREIGN_STASH */

       #define SP_MAYBE_UNLOCK_SINGLE_THREADED_RESOURCE(_RESNAME)

#else  /* !MULTI_SP_AWARE */

  #if SP_STATIC_FOREIGN_RESOURCE
    #if SP_SINGLE_THREADED
    #error "SP_SINGLE_THREADED is not compatible with SP_STATIC_FOREIGN_RESOURCE"
    #endif /* SP_SINGLE_THREADED */
    #undef SP_SINGLE_THREADED
  #endif /* SP_STATIC_FOREIGN_RESOURCE */

  #if SP_SINGLE_THREADED
       #if  !(SP_FOREIGN_SPENV || 1) /* 3.9 always on */
       #error "SP_SINGLE_THREADED requires SP_FOREIGN_SPENV"
       #endif /* !SP_FOREIGN_SPENV */

       /* This foreign code can be used by multiple sicstus run-times
          but only one run-time at a time can be in the foreign
          resource. This is ensured by locking the resource
          mutex. Note that the foreign resource still is responsible
          for maintainging separate state (e.g., static variables) for
          each sicstus run-time.

          Problem is that we need to call SP_mutex_lock in the calling
          SICStus run-time *before* we put the API dispatch into the global
          variable (sp_GlobalSICStus).
       */

       #define SP_STUB_LOCAL_DECLARATIONS(_RESNAME)

       #if 1
       /* "Need a proper way to handle deadlock for single threaded foreign resources."
          [PM] 3.9b5 Solved by documenting that the foreign resource
          must ensure that this cannot happen. E.g., by not calling
          any prolog code (SP_query et al). */

       #define SP_STUB_SETUP_API(RESNAME)                                                     \
         {                                                                                    \
           SP_LOCK_SINGLE_THREADED_RESOURCE(RESNAME,spenv); /* obtain the mutex lock */       \
           /* Now this thread is the only one in this foreign resource */                     \
           sp_resource_nesting_ ## RESNAME ++;                                                \
           if (sp_resource_nesting_ ## RESNAME == 1) /* first run-time to enter */            \
             {                                                                                \
               (*GetSICStusDISPATCHAddress())=spenv; /* Make sure the SICStus API is available */  \
               SP_CALL_RESOURCE_CONTEXT_SWITCH_HOOK(RESNAME, 1 /* enter */);                  \
             }                                                                                \
             else /* recursive enter, might have changed run-time in the current thread */    \
             {                                                                                \
                if ((*GetSICStusDISPATCHAddress()) != spenv) /* other run-time than before */ \
                   {                                                                                       \
                      /* deadlock! */                                                                      \
                      fprintf(stderr, "\n *** ERROR: deadlock in foreign resource " #RESNAME "\n");        \
                      fprintf(stderr,    "*** ERROR: called from two SICStus run-times in same thread\n"); \
                      fprintf(stderr,    "*** ERROR: aborting.\n");                                        \
                      fflush(stderr);                                                                      \
                      abort();                                                                             \
                   }                                                                          \
             }                                                                                \
         }

       #else/* !1 */

       #define SP_STUB_SETUP_API(RESNAME)                                                     \
         {                                                                                    \
           SP_LOCK_SINGLE_THREADED_RESOURCE(RESNAME,spenv); /* obtain the mutex lock */       \
           /* Now this SICStus run-time is the only one in this foreign resource */           \
           sp_resource_nesting_ ## RESNAME ++;                                                \
           if (sp_resource_nesting_ ## RESNAME == 1)                                          \
             {                                                                                \
               (*GetSICStusDISPATCHAddress())=spenv; /* Make the SICStus API is available */  \
               SP_CALL_RESOURCE_CONTEXT_SWITCH_HOOK(RESNAME, 1 /* enter */);                  \
             }                                                                                \
         }
       #endif/* !1 */


       #define SP_MAYBE_UNLOCK_SINGLE_THREADED_RESOURCE(RESNAME)                          \
         {                                                                                \
           if (sp_resource_nesting_ ## RESNAME == 1)                                      \
             SP_CALL_RESOURCE_CONTEXT_SWITCH_HOOK(RESNAME, 0 /* exit */);                 \
           sp_resource_nesting_ ## RESNAME --;                                            \
           SP_ZAP_API_GLOBAL_IF_AT_TOPLEVEL(RESNAME);                                     \
           SP_UNLOCK_SINGLE_THREADED_RESOURCE(RESNAME,spenv);                             \
         }

       #if SP_NO_CONTEXT_SWITCH_HOOK
       #define SP_CALL_RESOURCE_CONTEXT_SWITCH_HOOK(_RESNAME, _ENTER) do{;}while(0)
       #else  /* !SP_NO_CONTEXT_SWITCH_HOOK (default) */

       #define SP_CALL_RESOURCE_CONTEXT_SWITCH_HOOK(RESNAME, ENTER) \
          SP_CONTEXT_SWITCH_HOOK ((ENTER)) /* SP_CONTEXT_SWITCH_HOOK is #defined in <RESNAME>_glue.h */

       #endif /* !SP_NO_CONTEXT_SWITCH_HOOK */


       #if DBG
       #define SP_ZAP_API_GLOBAL_IF_AT_TOPLEVEL(RESNAME) \
                 if (sp_resource_nesting_ ## RESNAME == 0) { \
                   SP_RES_IF_DBG(fprintf(stderr, "\n** Zapping sp_GlobalSICStus for " #RESNAME "\n")); \
                   (*GetSICStusDISPATCHAddress())=NULL; \
                 } \
                 else \
                 { \
                   SP_RES_IF_DBG(fprintf(stderr, "\n** NOT Zapping sp_GlobalSICStus (nesting %d) for " #RESNAME "\n", sp_resource_nesting_ ## RESNAME)); \
                 }
       #else  /* !DBG */
       #define SP_ZAP_API_GLOBAL_IF_AT_TOPLEVEL(_RESNAME)
       #endif /* !DBG */



  #else  /* !SP_SINGLE_THREADED */

       #define SP_STUB_LOCAL_DECLARATIONS(_RESNAME)
       #if SP_FOREIGN_SPENV || 1 /* 3.9 always on */
       #define SP_STUB_SETUP_API(_RESNAME) /* nothing */
       #elif SP_FOREIGN_STASH
       #define SP_STUB_SETUP_API(_RESNAME) (void)pstash; /* avoid unused variable warning */
       #else /* !SP_FOREIGN_STASH */
       #define SP_STUB_SETUP_API(_RESNAME)
       #endif /* !SP_FOREIGN_STASH */

       #define SP_MAYBE_UNLOCK_SINGLE_THREADED_RESOURCE(_RESNAME)

  #endif /* !SP_SINGLE_THREADED */
#endif /* !MULTI_SP_AWARE */

#endif /* INCLUDED_IN_FOREIGN_RESOURCE */

typedef enum {
  sp_main_no_err=0,
  sp_main_err_param=1,          /* Incorrect parameters (probably called by non-SP_DISPATCH_API run-time) */
  /* Version mismatch between this resource and (calling run-time or calling params) */
  sp_main_version_err=2,
  /* non-MULTI_SP foreign resource invoked from more than once run-time */
  sp_main_err_multiple=3,
  sp_main_err_mutex=4
} sp_main_errcode;


/* foreign resource include this file just before 
   calling sp_main_helper so we can (and must if SP_STATIC_FOREIGN_RESOURCE)
   make it static   */
#if INCLUDED_IN_FOREIGN_RESOURCE
static
/* This avoids a (valid) GCC warning about sp_main_helper being declared extern */
#define sp_main_helper sp_main_helper_static
#endif /* INCLUDED_IN_FOREIGN_RESOURCE */

/* the generated sp_main_<RESOURCE> will just call sp_main_helper to do the work */
int SPCDECL sp_main_helper(SP_MAINFUN_PARAMS *params,
                           unsigned long version,
                           SICSTUS_API_STRUCT_TYPE **papi,
                           SP_mutex *mutex,
                           const SP_GlueFunPtr  funcs[],
                           const char* prednames[],
                           const int   arities[],
                           SP_InitFun* init_fun,
                           SP_InitFun* deinit_fun
                           )
{
  int err_code = 1;
  static int invocations = 0;
  SICSTUS_API_STRUCT_TYPE *api;

  if (version != SP_MAINFUN_PARAMS_VERSION) { err_code = sp_main_version_err; goto barf; }
  if (params->version != version) { err_code = sp_main_version_err; goto barf; }

#if SP_FOREIGN_SPENV || 1 /* 3.9 always on */
  api = params->spenv;
#else  /* !SP_FOREIGN_SPENV */
  api = params->api_dispatch;
#endif

  (void)invocations;            /* [PM] 3.9b5 avoid -Wunused */
  (void)papi;                   /* [PM] 3.9b5 avoid -Wunused */
  (void)mutex;                  /* [PM] 3.9b5 avoid -Wunused */
  (void)api;                    /* [PM] 3.9.1 avoid "set but never used" */

/********* JD: I REMOVED checking for multiple use of the resource.
           It caused problems if the module was loaded by both Python and Sicstus;
           Sicstus *thought* it removed it, while it actually stayed loaded because
           of Python. */

  params->funcs = funcs;
  params->prednames = prednames;
  params->arities = arities;
  params->init_fun = init_fun;
  params->deinit_fun = deinit_fun;
  err_code = 0;
 barf:
  return err_code;
}

#endif /* INCLUDED_IN_FOREIGN_RESOURCE */

#endif /* !SPLD_GENERATE_MAIN */
